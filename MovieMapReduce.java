import java.io.DataInput;
import java.io.DataOutput;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.ArrayWritable;
import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.LongWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.io.Writable;
import org.apache.hadoop.io.WritableComparable;
import org.apache.hadoop.io.WritableUtils;
import org.apache.hadoop.mapreduce.Job;
import org.apache.hadoop.mapreduce.Mapper;
import org.apache.hadoop.mapreduce.Reducer;
import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
import org.apache.hadoop.mapreduce.lib.input.SequenceFileInputFormat;
import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;
import org.apache.hadoop.mapreduce.lib.output.SequenceFileOutputFormat;

/**
 * 
 * @author Natasha Jenny, 19 October 2019
 * 
 */

public class MovieMapReduce {	

	/**
	 * MovieRatingMap is a custom object which implements Writable
	 * to store the value generated by UserMapper
	 *
	 */
	public static class MovieRatingMap implements Writable {
		private Text movie;
		private IntWritable rating;

		/**
		 * @param movie		the movie watched and rated by each user key
		 * @param rating	the rating given for the movie
		 */
		public MovieRatingMap() {
			this.movie = new Text("");
			this.rating = new IntWritable(-1);
		}

		public MovieRatingMap(Text movie, IntWritable rating) {
			super();
			this.movie = movie;
			this.rating = rating;
		}
		
		public Text getMovie() {
			return movie;
		}

		public void setMovie(Text movie) {
			this.movie = movie;
		}

		public IntWritable getRating() {
			return rating;
		}

		public void setRating(IntWritable rating) {
			this.rating = rating;
		}


		@Override
		public void readFields(DataInput in) throws IOException {
			this.movie.readFields(in);
			this.rating.readFields(in);
		}

		@Override
		public void write(DataOutput out) throws IOException {
			this.movie.write(out);
			this.rating.write(out);
		}

		/**
		 * @return the movie and associated rating given by the user key
		 * in the form of {movie, rating}
		 */
		@Override
		public String toString() {
			return this.movie.toString() + "," + this.rating.toString() + " ";
		}
		
	}
	
	
	/**
	 * MovieRatingArray is a custom writable object to store
	 * The (movie,rating) values for each user
	 */
	public static class MovieRatingArray extends ArrayWritable {
		public MovieRatingArray() {
			super(Text.class);
		}
		
		public MovieRatingArray(String[] values) {
			super(Text.class);
			Text[] text = new Text[values.length];
			for (int i = 0; i < values.length; i++) {
				text[i] = new Text(values[i]);
			}
			set(text);
		}

		/**
		 * toString() overriden to output result string array
		 * in the form of (movie_1,rating_1 movie_2,rating_2 ...)
		 */
		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("");
			for (String s : super.toStrings()) {
				sb.append(s);
				sb.append(" ");
			}
			return sb.toString().trim();
		}	
	}
	
	/**
	 * RatingPair is the value for MovieReducer
	 * A complex object which implements Writable
	 *
	 */
	public static class RatingPair implements Writable {
		private Text user;
		private IntWritable rating1;
		private IntWritable rating2;
		
		/**
		 * Given a key (movie_1, movie_2)
		 * @param user		The user_id who watched and rated movie pair (movie_1, movie_2)
		 * @param rating1	The rating given by user for movie_1
		 * @param rating2	The rating given by user for movie_2
		 */
		public RatingPair() {
			this.user = new Text("");
			this.rating1 = new IntWritable(-1);
			this.rating2 = new IntWritable(-1);
		}

		public RatingPair(Text user, IntWritable rating1, IntWritable rating2) {
			super();
			this.user = user;
			this.rating1 = rating1;
			this.rating2 = rating2;
		}

		@Override
		public void readFields(DataInput in) throws IOException {
			this.user.readFields(in);;
			this.rating1.readFields(in);;
			this.rating2.readFields(in);;
		}

		@Override
		public void write(DataOutput out) throws IOException {
			this.user.write(out);
			this.rating1.write(out);
			this.rating2.write(out);
		}

		/**
		 * Overrides toString() to return in the form of (user,rating_1,rating_2)
		 */
		@Override
		public String toString() {
			return "(" + user + "," + rating1.toString() + "," + rating2.toString() + ")";
		}
		
	}
	
	/**
	 * MoviePair is a complex key object which implements WritableComparable
	 * Key for MovieMapper in the form of (movie_1, movie_2)
	 */
	public static class MoviePair implements WritableComparable<MoviePair> {
		private String first, second;
		
		public MoviePair() {}

		/**
		 * @param first		first movie in the pair/key
		 * @param second	second movie in the pair/key
		 */
		public MoviePair(String first, String second) {
			this.first = first;
			this.second = second;
		}
		
		public String getFirst() {
			return first;
		}

		public void setFirst(String first) {
			this.first = first;
		}

		public String getSecond() {
			return second;
		}

		public void setSecond(String second) {
			this.second = second;
		}
	
		
		/**
		 * readFields overridden to account for string array
		 */
		@Override
		public void readFields(DataInput in) throws IOException {
			String[] str = WritableUtils.readStringArray(in);
			this.first = str[0];
			this.second = str[1];
		}

		/**
		 * write overridden to account for string array
		 */
		@Override
		public void write(DataOutput out) throws IOException {
			String[] str = new String[] {first, second};
			WritableUtils.writeStringArray(out, str);
		}
		

		private int compare(String s1, String s2) {
			if (s1 == null && s2 == null) {
				return 0;
			} else if (s1 == null && s2 != null) {
				return -1;
			} else if (s1 != null && s2 == null) {
				return 1;
			} else {
				return s1.compareTo(s2);
			}
		}

		/**
		 * compareTo is overriden to account for pair key (first, second)
		 */
		@Override
		public int compareTo(MoviePair o) {
			int comp = compare(first, o.getFirst());
			if (comp != 0) {
				return comp;
			}
			return compare(second, o.getSecond());
		}

		/**
		 * toString() overriden to return movie pair in the form of (first,second)
		 */
		@Override
		public String toString() {
			return "(" + first + "," + second + ")";
		}
	}
	
	
	/**
	 * ResultWritable is a complex object which implements ArrayWritable
	 * Is the value for MovieReducer
	 */
	public static class ResultWritable extends ArrayWritable {
		public ResultWritable() {
			super(Text.class);
		}
		
		public ResultWritable(String[] values) {
			super(Text.class);
			Text[] text = new Text[values.length];
			for (int i = 0; i < values.length; i++) {
				text[i] = new Text(values[i]);
			}
			set(text);
		}

		/**
		 * toString() overriden to output result string array
		 * in the form of [(user, rating_1, rating_2), ..]
		 */
		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("[");
			String prefix = "";
			for (String s : super.toStrings()) {
				sb.append(prefix);
				prefix = ",";
				sb.append(s);
			}
			sb.append("]");
			return sb.toString();
		}	
	}
	
	/**
	 * UserMapper takes the input and maps them
	 * Input text is mapped to (user -> (movie, rating))
	 */
	public static class UserMapper extends Mapper<LongWritable, Text, Text, MovieRatingMap> {

		@Override
		protected void map(LongWritable key, Text value, Mapper<LongWritable, Text, Text, MovieRatingMap>.Context context)
				throws IOException, InterruptedException {
			String[] tokens = value.toString().split("::");
			MovieRatingMap val = new MovieRatingMap();
			
			if (tokens.length > 1) {
				val.setMovie(new Text(tokens[1]));
				val.setRating(new IntWritable(Integer.parseInt(tokens[2])));
				
				context.write(new Text(tokens[0]), val);
			}
		}
		
	}
	
	/**
	 * UserReducer receives the values from the mapper
	 * (user -> (movie,rating)) is reduced to (user -> [(movie_1,rating_1),(movie_2,rating_2),...]
	 */
	public static class UserReducer extends Reducer<Text, MovieRatingMap, Text, MovieRatingArray> {

		@Override
		protected void reduce(Text key, Iterable<MovieRatingMap> values,
				Reducer<Text, MovieRatingMap, Text, MovieRatingArray>.Context context)
				throws IOException, InterruptedException {
			String movieRating = "";
			
			for (MovieRatingMap v: values) {
				movieRating += v.toString();
			}
			
			String[] tokens = movieRating.split(" ");
			
			context.write(key, new MovieRatingArray(tokens));

		}
		
	}
	
	/**
	 * MovieMapper maps from the output of UserReducer in a separate job
	 * (User -> MovieRatingArray) is remapped as (MoviePair -> RatingPair)
	 * Maps each movie pair to (user, rating pair)
	 */
	public static class MovieMapper extends Mapper<Text, MovieRatingArray, MoviePair, RatingPair> {

		protected void map(Text in, MovieRatingArray value,
				Mapper<Text, MovieRatingArray, MoviePair, RatingPair>.Context context)
				throws IOException, InterruptedException {
			String key = in.toString().trim();
			ArrayList<String> pairs = new ArrayList<>();
			
			for (Writable w: value.get()) {
				Text text = (Text)w;
				pairs.add(text.toString());
			}
			
			for (int i = 0; i < pairs.size(); i++) {
				for (int j = i+1; j < pairs.size(); j++) {
					// Combine 2 pairs of movies with a delimiter "," and then split it
					String pair = pairs.get(i) + "," + pairs.get(j);
					String[] movieRatings = pair.split(",");
					
					// If the loop reaches 2 pairs of movies, ratings
					if (movieRatings.length == 4) {
						// This comparison is to ensure key_1 < key_2
						if (movieRatings[0].compareTo(movieRatings[2]) > 0) {
							MoviePair moviePair = new MoviePair(movieRatings[2], movieRatings[0]);
							RatingPair ratingPair = new RatingPair(new Text(key), new IntWritable(Integer.parseInt(movieRatings[3])), new IntWritable(Integer.parseInt(movieRatings[1])));
							context.write(moviePair, ratingPair);
						} else {
							MoviePair moviePair = new MoviePair(movieRatings[0], movieRatings[2]);
							RatingPair ratingPair = new RatingPair(new Text(key), new IntWritable(Integer.parseInt(movieRatings[1])), new IntWritable(Integer.parseInt(movieRatings[3])));
							context.write(moviePair, ratingPair);
						}
					}	
				}
			}
		}
	}
	
	/**
	 * MovieReducer reduces from the output of MovieMapper
	 * (MoviePair -> RatingPair) reduced to (MoviePair -> ResultWritable)
	 * To store the user rating tuples
	 * 
	 */
	public static class MovieReducer extends Reducer<MoviePair, RatingPair, MoviePair, ResultWritable> {
	
		@Override
		protected void reduce(MoviePair movies, Iterable<RatingPair> ratings,
				Reducer<MoviePair, RatingPair, MoviePair, ResultWritable>.Context context)
				throws IOException, InterruptedException {
			ArrayList<String> pairs = new ArrayList<>();
			
			for (RatingPair r:ratings) {
				pairs.add(r.toString());
			}
			
			String[] user_ratings = new String[pairs.size()];
			
			for (int i = 0; i < pairs.size(); i++) {
				user_ratings[i] = pairs.get(i);
			}
			context.write(movies, new ResultWritable(user_ratings));
		}

	}

	/**
	 * @param args
	 * @throws Exception
	 * Main driver of the program, creates and chains 2 jobs
	 * 
	 */
	public static void main(String[] args) throws Exception {
		Path out = new Path(args[1]);
		Configuration conf = new Configuration();
		
		Job job1 = Job.getInstance(conf, "Job 1");
		job1.setMapOutputKeyClass(Text.class);
		job1.setMapOutputValueClass(MovieRatingMap.class);
		job1.setOutputKeyClass(Text.class);
		job1.setOutputValueClass(MovieRatingArray.class);
		job1.setMapperClass(UserMapper.class);
		job1.setReducerClass(UserReducer.class);
		job1.setOutputFormatClass(SequenceFileOutputFormat.class);
		
		FileInputFormat.addInputPath(job1, new Path(args[0]));
		FileOutputFormat.setOutputPath(job1, new Path(out, "temp"));
	
		if (!job1.waitForCompletion(true)) {
			System.exit(1);
		}
		
		Job job2 = Job.getInstance(conf, "Job 2");
		job2.setMapperClass(MovieMapper.class);
		job2.setReducerClass(MovieReducer.class);
		job2.setMapOutputKeyClass(MoviePair.class);
		job2.setMapOutputValueClass(RatingPair.class);
		job2.setOutputKeyClass(MoviePair.class);
		job2.setOutputValueClass(ResultWritable.class);
		job2.setInputFormatClass(SequenceFileInputFormat.class);
		
		FileInputFormat.addInputPath(job2, new Path(out, "temp"));
		FileOutputFormat.setOutputPath(job2, new Path(out, "out"));
		
		if (!job2.waitForCompletion(true)) {
			System.exit(1);
		}
	}

}
